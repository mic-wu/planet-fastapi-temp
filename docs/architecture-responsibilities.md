# Architecture & Responsibilities: Data Flow & API Design

**Date**: 2025-01-27  
**Purpose**: Clarify what belongs in each layer of the system

---

## System Architecture Overview

```
┌─────────────┐
│ Planet API  │
│ (External)  │
└──────┬──────┘
       │
       │ fetch_stories.py (Data Ingestion Script)
       │ - Fetches data
       │ - Parses/transforms
       │ - Stores in DB
       ▼
┌─────────────┐
│  Supabase   │
│   Database  │
│(planet_stories)│
└──────┬──────┘
       │
       │ FastAPI Backend (API Layer)
       │ - Reads from DB
       │ - Applies filters
       │ - Returns data
       ▼
┌─────────────┐      ┌─────────────┐
│  Frontend   │      │   Admin     │
│  (Gallery)  │      │  Interface  │
└─────────────┘      └─────────────┘
```

---

## Layer Responsibilities

### 1. Data Ingestion Layer (`fetch_stories.py`)

**Purpose**: Fetch data from Planet API and store in Supabase

**Responsibilities**:

- ✅ Fetch data from Planet API (`https://api.planet.com/explorer/t2/animations`)
- ✅ Parse Planet API response
- ✅ Transform Planet API format → Supabase schema
- ✅ Store data in Supabase `planet_stories` table
- ✅ Handle errors (API failures, DB errors)

**What it does**:

```python
# Fetches from Planet API
stories = fetch_stories(limit=20)

# Transforms to Supabase format
story_data = {
    'id': story.get('id'),
    'title': story.get('title'),
    'author': story.get('author'),
    'format': story.get('format'),  # "mp4" or "raw"
    'created': story.get('created'),
    'updated': story.get('updated'),
    'center_long': center[0],
    'center_lat': center[1],
    'view_link': f"https://www.planet.com/stories/{story_id}"
}

# Stores in Supabase
supabase.table("planet_stories").upsert(story_data)
```

**What it does NOT do**:

- ❌ Generate image URLs (frontend does this)
- ❌ Derive categories (frontend does this)
- ❌ Serve API requests (FastAPI does this)
- ❌ Handle user requests (FastAPI does this)

**When it runs**: Scheduled job (cron) or manual execution

---

### 2. Database Layer (Supabase)

**Purpose**: Store raw story data

**What it stores**:

- Raw data from Planet API (as transformed by `fetch_stories.py`)
- No derived/computed fields
- No presentation logic

**Schema**:

```sql
planet_stories:
  - id (text)
  - title (text)
  - author (text)
  - format (text)  -- "mp4" or "raw"
  - created (timestamp)
  - updated (timestamp)
  - center_long (numeric)
  - center_lat (numeric)
  - view_link (text)
```

**What it does NOT store**:

- ❌ `category` field (derived from `format` by frontend)
- ❌ `thumbnail_url` (generated by frontend)
- ❌ `image_url` (generated by frontend)
- ❌ `location` string (could be derived from coordinates later)

---

### 3. API Layer (FastAPI Backend)

**Purpose**: Provide HTTP API for accessing story data

#### What SHOULD be in the API

**✅ Data Access & Filtering**:

- Read from Supabase
- Apply filters (category → format mapping, search)
- Pagination logic
- Return data in API response format

**✅ Business Logic**:

- Category → Format mapping for filtering
- Search logic (title search)
- Pagination calculations
- Data validation

**✅ Response Transformation**:

- Map Supabase fields → API response fields
- Convert timestamps to ISO 8601 strings
- Build `story_metadata` object
- Return `null` for client-generated fields

**✅ Admin Operations** (Post-MVP):

- Create/Update/Delete stories
- Authentication/authorization
- Input validation

#### What should NOT be in the API

**❌ URL Generation**:

- Don't generate `thumbnail_url` or `image_url`
- Frontend generates these client-side from `format` + `id`

**❌ Category Derivation**:

- Don't derive `category` from `format`
- Frontend derives this client-side
- API only uses `category` for filtering (maps to `format`)

**❌ Location Geocoding**:

- Don't convert coordinates to location strings
- Can add later if needed, but not MVP

**❌ Data Ingestion**:

- Don't fetch from Planet API
- That's `fetch_stories.py`'s job
- API only reads from Supabase

---

### 4. Frontend Layer (Next.js)

**Purpose**: Display stories and handle user interactions

#### What SHOULD be in the Frontend

**✅ Presentation Logic**:

- Generate `thumbnail_url` and `image_url` from `format` + `id`
- Derive `category` from `format` for display
- Handle image loading errors
- Show placeholders for missing images

**✅ User Interface**:

- Gallery grid display
- Filter UI (Image/Video tabs)
- Search input
- Pagination controls
- Modal/details view

**✅ Client-Side Filtering** (if needed):

- Filter by derived category
- Filter by metadata (sensor, resolution)

#### What should NOT be in the Frontend

**❌ Database Access**:

- Don't query Supabase directly
- Use FastAPI endpoints

**❌ Data Ingestion**:

- Don't fetch from Planet API
- That's `fetch_stories.py`'s job

**❌ Business Logic** (some exceptions):

- URL generation is OK (presentation logic)
- Category derivation is OK (presentation logic)
- But complex business rules should be in API

---

## Data Flow Examples

### Example 1: Displaying Stories in Gallery

```
1. Frontend → GET /api/stories/?page=1&limit=12&category=video
   ↓
2. FastAPI Backend:
   - Maps category="video" → format="mp4"
   - Queries Supabase: SELECT * FROM planet_stories WHERE format='mp4'
   - Applies pagination
   - Transforms response (adds story_metadata, nulls for client fields)
   ↓
3. Returns:
   {
     "data": [
       {
         "id": "story-1",
         "format": "mp4",  // ← Frontend uses this
         "category": null,  // ← Frontend generates this
         "thumbnail_url": null,  // ← Frontend generates this
         ...
       }
     ]
   }
   ↓
4. Frontend:
   - Receives data
   - Generates: category = formatToCategory("mp4") = "video"
   - Generates: thumbnail_url = generateUrl("story-1", "mp4")
   - Displays in gallery
```

### Example 2: Data Ingestion

```
1. Cron job runs fetch_stories.py
   ↓
2. fetch_stories.py:
   - Fetches from Planet API
   - Transforms to Supabase format
   - Stores in Supabase
   ↓
3. Supabase now has new/updated stories
   ↓
4. Frontend can fetch via FastAPI (no direct DB access)
```

---

## Decision Matrix: Where Should This Logic Live?

| Feature | fetch_stories.py | Supabase | FastAPI | Frontend |
|---------|------------------|----------|---------|----------|
| Fetch from Planet API | ✅ | ❌ | ❌ | ❌ |
| Store raw data | ✅ | ✅ (storage) | ❌ | ❌ |
| Read from DB | ❌ | ❌ | ✅ | ❌ |
| Category → Format mapping (filtering) | ❌ | ❌ | ✅ | ❌ |
| Format → Category derivation (display) | ❌ | ❌ | ❌ | ✅ |
| Generate image URLs | ❌ | ❌ | ❌ | ✅ |
| Pagination logic | ❌ | ❌ | ✅ | ❌ |
| Search logic | ❌ | ❌ | ✅ | ❌ |
| Build story_metadata object | ❌ | ❌ | ✅ | ❌ |
| Convert timestamps to ISO 8601 | ❌ | ❌ | ✅ | ❌ |
| Handle image errors | ❌ | ❌ | ❌ | ✅ |
| Display gallery UI | ❌ | ❌ | ❌ | ✅ |

---

## API Responsibilities Summary

### FastAPI Backend SHOULD

1. **Read from Supabase**
   - Query `planet_stories` table
   - Apply filters (category → format, search)
   - Handle pagination

2. **Transform Response Format**
   - Map Supabase fields → API response fields
   - Add `story_metadata` object
   - Convert timestamps to ISO 8601
   - Return `null` for client-generated fields

3. **Handle Filtering Logic**
   - Map `category` parameter → `format` filter
   - Implement search in `title` field
   - Combine filters correctly

4. **Admin Operations** (Post-MVP)
   - Create/Update/Delete stories
   - Validate input
   - Handle authentication

### FastAPI Backend should NOT

1. **Generate URLs**
   - Don't generate `thumbnail_url` or `image_url`
   - Frontend does this from `format` + `id`

2. **Derive Categories**
   - Don't compute `category` from `format`
   - Frontend does this for display
   - API only uses `category` for filtering (maps to `format`)

3. **Fetch from Planet API**
   - That's `fetch_stories.py`'s job
   - API only reads from Supabase

4. **Do Geocoding**
   - Don't convert coordinates to location strings
   - Can add later, but not MVP

---

## Recommended API Implementation

### GET /api/stories/ (List Stories)

**What API does**:

1. Read from Supabase `planet_stories` table
2. Map `category` filter → `format` filter
3. Apply search filter (title)
4. Apply pagination
5. Transform to API response format:
   - Add `story_metadata` object
   - Convert timestamps
   - Return `null` for client fields
6. Return paginated response

**What API does NOT do**:

- Generate URLs (frontend does this)
- Derive categories (frontend does this)

### Response Structure

```json
{
  "data": [
    {
      "story_id": "story-1",
      "id": "story-1",
      "title": "Example",
      "format": "mp4",  // ← API returns this
      "category": null,  // ← API returns null, frontend generates
      "thumbnail_url": null,  // ← API returns null, frontend generates
      "image_url": null,  // ← API returns null, frontend generates
      "story_metadata": {  // ← API builds this
        "author": "...",
        "format": "mp4",
        "center": [...],
        "view_link": "..."
      },
      ...
    }
  ],
  "total": 100,
  "page": 1,
  "limit": 12,
  "has_more": true
}
```

---

## Key Principles

1. **Single Source of Truth**: Supabase is the source of truth for story data
2. **Separation of Concerns**: Each layer has clear responsibilities
3. **API as Data Access Layer**: API reads from DB, transforms format, returns data
4. **Frontend Handles Presentation**: URL generation, category derivation, UI logic
5. **Ingestion is Separate**: `fetch_stories.py` is independent script, not part of API

---

## Questions to Consider

1. **Should API cache data?**
   - Probably not needed for MVP
   - Can add later if performance issues

2. **Should API validate data?**
   - Yes, validate query parameters
   - Validate admin input (POST/PUT)

3. **Should API handle rate limiting?**
   - Good idea for production
   - Not critical for MVP

4. **Should API do any data enrichment?**
   - Only build `story_metadata` object
   - Don't do geocoding, URL generation, etc.

---

## Summary

**FastAPI Backend is**:

- Data access layer (reads from Supabase)
- Filter/pagination logic
- Response transformation (format, not content)
- Admin CRUD operations (Post-MVP)

**FastAPI Backend is NOT**:

- Data ingestion (that's `fetch_stories.py`)
- URL generator (that's frontend)
- Category deriver (that's frontend)
- Geocoding service (can add later)

**Keep it simple**: API reads from DB, applies filters, transforms format, returns data. Frontend handles presentation logic.
